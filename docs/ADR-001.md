# ADR-001: Choice of Architecture and Main Design Patterns


## Context

The goal is to build a Flutter application to explore events in a city. Non-functional requirements demand a layered architecture, a modern state management solution, and a testing strategy that covers both business logic and the user interface. The application must be maintainable, scalable, and testable.

## My Decision

After evaluating several options, I decided to use:

- **Clean Architecture** as the structural basis.
- **Riverpod** for state management and dependency injection.
- **GoRouter** for declarative navigation.

I chose these tools because they are the ones I feel most comfortable with and allow me to move quickly, while also meeting maintainability and testability goals.

---

### 1. Overall Architecture: Clean Architecture

I chose **Clean Architecture** because it helps separate responsibilities and keeps business logic independent from Flutter or the data sources. The structure I’m using is:

- **`domain`**: Contains the entities (`Event`, `Location`), repository contracts, and use cases. This layer does **not depend on anything external**, making it easy to test the logic without touching the UI or persistence details.

- **`data`**: Implements the contracts from `domain`. Contains data sources (like `LocalEventDataSource`) and the concrete repository logic. In the future, if I switch from a local JSON to REST or SQLite, the UI won’t be affected.

- **`presentation`**: The UI and presentation logic. Here I use Flutter widgets and Riverpod to manage state. It depends on `domain` but **not on `data` directly**, keeping the layers decoupled.

**Why I did it this way:**  
This structure makes the code more organized, testable, and flexible. I can change the data layer or the UI without breaking the business logic, giving me confidence to evolve the app.

---

### 2. State Management and Dependency Injection: Riverpod

I chose **Riverpod** for several reasons:

- **BuildContext independence**: Providers can be accessed from anywhere in the app.
- **Compile-time safety**: Reduces runtime errors like `ProviderNotFoundException`.
- **Automatic lifecycle management**: With `.autoDispose`, providers free memory when no longer in use.
- **Clear and testable DI**: Makes it easy to create dependencies and replace them in tests.

**Why I like it:**  
It’s a modern and flexible solution for managing state and dependencies in Flutter, and it allows me to implement the favorites logic and UI updates clearly.

---

### 3. Navigation: GoRouter

I chose **GoRouter** because:

- It allows defining routes declaratively and URL-based.
- Simplifies deep linking and decouples navigation from widgets.
- Keeps the route configuration centralized, making it easier to modify navigation if needed.

---

### 4. Testing Strategy

I want to cover both logic and UI. For this:

- **Logic test (unit test)**: I focus on the **favorites functionality**, which contains most of the business logic. I verify that the favorites state updates correctly.

- **Widget test**: I focus on the **events list**, making sure the widgets display test data correctly and render as expected.

---

## Consequences

### Positives

- Maintainable and testable code from the start.
- Clear separation of responsibilities; I can add new features without breaking existing functionality.
- Predictable state and efficient memory management thanks to Riverpod.
- Robust and centralized navigation with GoRouter.
- Tests cover both core logic (favorites) and event list display, giving confidence that the app works correctly.

### Trade-offs

- **More boilerplate at first**: Clean Architecture requires more files and structure, but it’s worth it for long-term maintainability.
- **Simple local pagination**: Using local JSON, the whole list is loaded into memory to filter and paginate. With a real backend, this would be more efficient.
- **Static map**: To simplify, I use a static map image instead of an interactive widget, reducing complexity and external API dependencies.
